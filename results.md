Leading Question:

Our leading question for this project was the following: given a dataset of Netflix movies, what movies are most similar to a movie provided by the user? For example, one query the user can make is what movie is most similar to Black Panther, which is a specific movie that the user can input. The output is a list of top x movies that are most similar to what the user’s query is. Initially, we wanted to provide extra functionality for the user where they could ask for movie recommendations based on certain characteristics, such as genre or the level of popularity, but due to time constraints, we were not able to finish it. We did play around with it by discussing how we could change our design to fit this need in addition to how we would parse the dataset for just those specific queries that the user makes. 
	We answered this question by designing our solution with the help of 3 data structures. We used an adjacency matrix as a vector of vectors of type doubles to track the scores for how closely related one movie is related to get a given movie’s list of neighbors. Additionally, we had two maps that would allow you to access a specific show/movie given its index or the index of a show/movie given its MotionPicture object pointer. For each show/movie, we designed a MotionPicture class that would consist of all movie attributes from which the user can specify in their queries. In addition to these data structures, we used the Breadth First Search algorithm and Dijsktra’s algorithm to output the top x (x inputted by user) movies that are related to one another based on what the user queries. Lastly, we used the Betweenness Centrality algorithm to show whether or not a certain movie existed in a path between two movies in the adjacency matrix and took into consideration various conditions, such as whether or not a path existed between two movies. 
One interesting problem we encountered was trying to figure out how to tackle this problem in the design aspect. We constantly went back and forth on what the best data structure was to design this, and we initially had some thoughts about using an inner map within an outer map to store a specific movie’s list of neighbors in addition to their relational score. We soon realized we were overcomplicating the matter. Another lesson learned was to focus our testing and sampling on a certain subset of the data to improve runtime complexity. 




Algorithms:


Breadth First Search 

Our BFS algorithm relies on a queue to help filter through and parse the stored similarity scores in our adjacency matrix to find the movies with the highest similarity to the given movie input. This algorithm is adjusted to allow the user to ask for as many movie recommendations as they want which is only limited by the size of the movie database being used. If a user requests more movie recommendations than movies in the database, then the algorithm will spit out the similarities for only up to the number of movies in the database. All outputs are sorted from most similar to least similar for the given number of recommendations. We believe this algorithm has a space and time complexity of O(n). This algorithm also handles faulty inputs such as nonexistent movies being searched for and erroneous movie recommendation numbers such as -1. There were test cases created based off of the expected movie recommendations from this algorithm. The expected output is based off of the movies in the current dataset being analyzed and seeing if the correct recommendations are being produced based off of the similarity scored included in our adjacency matrix. The output is as expected for all of our test cases and we believe this algorithm works correctly.

Dijsktra’s Algorithm

Similar to the BFS algorithm, Dijstra’s algorithm is used to help us find the movies with the highest similarities using our adjacency matrix of similarity scores to output a movie recommendation list. The function here has two inputs, a movie being searched from and a count of how many recommendations the user is interested in. Dijkstra’s algorithm is a shortest path algorithm that is used on the graph to help us achieve this. We believe this algorithm has a space complexity of O(N^2) and a time complexity of O(M+NlogN). Similar to the BFS algorithm, this algorithm handles faulty inputs such as bad movies being searched for and bad recommendation counts being requested. There were test cases created based off of the expected movie recommendations from this algorithm. The expected output is based off of what we expect the recommendations to be based off of the adjacency matrix and seeing if the algorithm reqcommends the correct movies in the correct order. All of the test cases produce correct results and therefore we believe this algorithm works correctly.

Betweenness Centrality Algorithm 

The betweenness centrality algorithm calculates the shortests paths among all nodes. The way in which we approached this algorithm was by dividing the task into two. First, we needed to determine if there was a path between a starting node and an ending node. Since our graph representation was an adjacency matrix, two nodes were connected as long as their edge weights were > 0 (-1 edge weight if a node was compared with itself).The entire goal of this algorithm is to figure out if certain movies are related to one another. The space complexity is O(m + n) where m and n are the number of edges and vertices in the graph. The time complexity is O(nm + n^2 (log n)). To ensure our algorithm was working correctly, we depicted sample graphs from subsets of our data then manually calculated what the output should be using our knowledge of this algorithm. For example, we took in the index of the MotionPicture pointer object that it corresponds to in the mp_to_idx map, and we outputted the score for that specific movie object. Then, we ran our method in the main file and compared any discrepancies between the outputs. We used the Catch.hpp testing framework to accomplish this. 
