
Leading Question:

Our leading question for this project was the following: given a dataset of Netflix movie/shows, what movie/shows are most similar to a movie/show provided by the user? For example, one query the user can make is what movie/show is most similar to Black Panther, which is a specific movie/show that the user can input. The output is a list of top x movie/shows that are most similar to what the user’s query is. Initially, we wanted to provide extra functionality for the user where they could ask for movie/show recommendations based on certain characteristics, such as genre or the level of popularity, but due to time constraints, we were not able to finish it. We did play around with it by discussing how we could change our design to fit this need in addition to how we would parse the dataset for just those specific queries that the user makes. 
	We answered this question by designing our solution with the help of 3 data structures. We used an adjacency matrix as a vector of vectors of type doubles to track the scores for how closely related one movie/show is related to get a given movie/show’s list of neighbors. Additionally, we had two maps that would allow you to access a specific show/movie given its index or the index of a show/movie given its MotionPicture object pointer. For each show/movie, we designed a MotionPicture class that would consist of all movie/show attributes from which the user can specify in their queries. In addition to these data structures, we used the Breadth First Search algorithm and Dijsktra’s algorithm to output the top x (x inputted by user) movie/shows that are related to one another based on what the user queries. Lastly, we used the Betweenness Centrality algorithm to show whether or not a certain movie/show existed in a path between two movies/shows in the adjacency matrix and took into consideration various conditions, such as whether or not a path existed between two movie/shows. 
One interesting problem we encountered was trying to figure out how to tackle this problem in the design aspect. We constantly went back and forth on what the best data structure was to design this, and we initially had some thoughts about using an inner map within an outer map to store a specific movie/show’s list of neighbors in addition to their relational score. We soon realized we were overcomplicating the matter. Another lesson learned was to focus our testing and sampling on a certain subset of the data to improve runtime complexity. 

Algorithms:



Breadth First Search 

Our BFS algorithm relies on a queue to help filter through and parse the stored similarity scores in our adjacency matrix to find the MotionPicture with the highest similarity to the given MotionPicture input. This algorithm is adjusted to allow the user to ask for as many MotionPicture recommendations as they want which is only limited by the size of the MotionPicture database being used. If a user requests more MotionPicture recommendations than MotionPicture in the database, then the algorithm will spit out the similarities for only up to the number of MotionPicture in the database. All outputs are sorted from most similar to least similar for the given number of recommendations. We believe this algorithm has a space and time complexity of O(n). This algorithm also handles faulty inputs such as nonexistent MotionPicture being searched for and erroneous MotionPicture recommendation numbers such as -1. There were test cases created based off of the expected MotionPicture recommendations from this algorithm. The expected output is based off of the MotionPicture in the current dataset being analyzed and seeing if the correct recommendations are being produced based off of the similarity scored included in our adjacency matrix. The output is as expected for all of our test cases and we believe this algorithm works correctly.


Dijsktra’s Algorithm

Similar to the BFS algorithm, Dijstra’s algorithm is used to help us find the MotionPicture with the highest similarities using our adjacency matrix of similarity scores to output a MotionPicture recommendation list. The function here has two inputs, a MotionPicture being searched from and a count of how many recommendations the user is interested in. Dijkstra’s algorithm is a shortest path algorithm that is used on the graph to help us achieve this. We believe this algorithm has a space complexity of O(N^2) and a time complexity of O(M+NlogN). Similar to the BFS algorithm, this algorithm handles faulty inputs such as bad MotionPicture being searched for and bad recommendation counts being requested. There were test cases created based off of the expected MotionPicture recommendations from this algorithm. The expected output is based off of what we expect the recommendations to be based off of the adjacency matrix and seeing if the algorithm reqcommends the correct MotionPicture in the correct order. All of the test cases produce correct results and therefore we believe this algorithm works correctly.


Betweenness Centrality Algorithm 

The betweenness centrality algorithm calculates the shortests paths among all nodes. The way in which we approached this algorithm was by dividing the task into two. First, we needed to determine if there was a path between a starting node and an ending node. Since our graph representation was an adjacency matrix, two nodes were connected as long as their edge weights were > 0 (-1 edge weight if a node was compared with itself).The entire goal of this algorithm is to figure out if certain MotionPicture are related to one another. The space complexity is O(m + n) where m and n are the number of edges and vertices in the graph. The time complexity is O(nm + n^2 (log n)). To ensure our algorithm was working correctly, we depicted sample graphs from subsets of our data then manually calculated what the output should be using our knowledge of this algorithm. For example, we took in the index of the MotionPicture pointer object that it corresponds to in the mp_to_idx map, and we outputted the score for that specific MotionPicture object. Then, we ran our method in the main file and compared any discrepancies between the outputs. We used the Catch.hpp testing framework to accomplish this. 
